%function t_node=testNetworkAddMeasurements(t_node,G,varargin)
%Add the absolute poses contained in G and relative transformations to the
%t_node structure. By default the relative changes of reference are exact and
%computed from G (which is equivalent to 'Method','Truth' below)
%Optional arguments
%   'Method',method     defines which method to use to generate the
%                       relative changes of reference. method can be:
%       'Truth'             computed from G (but with normalized translations)
%       'TruthRotationsOnly'
%                           Same as 'Truth', but sets only the rotations
%       'Noisy'             similar to 'Truth' but with the addition of noise
%                           (see below for the variance parameters)
%       'Essential'         use points and the essential matrix
%                           (see below for image noise variance parameter)
%                           (requires either the option 'Points' or the fields
%                           t_node.ximage generated by testNetworkProjectImages)
%       'Given',pairs       pairs contains the pairwise measurements to
%                           use. If t_node is of type 'array', pairs must
%                           be a [NCameras x NCameras] cell array. If
%                           t_node is of type 'single', pairs must be a [4
%                           x 4 x NEdges] array.
%       'GivenRotations',rotPairs 
%                           Same as 'Given', but only sets the rotation part
%       'Outliers',outList  outList is a (NOutliers x 2) matrix of
%                           containing a list of node pairs. Replaces each
%                           measurement of each edge in the list and the
%                           edge in the opposite direction with a random
%                           measurement drawn from a uniform distribution.
%                           It is intended to be run after one of the other
%                           options.
%       'OutlierTranslations', outList
%                           Same as 'Outliers', but only sets translations
%
%   'Points',X          Specify the 3-D points for generating the relative
%                       changes of reference for the 'Essential' method
%                       (the fields t_node().ximage are overwritten)
%   'SigmaT',S          Std of noise for translation with 'Noisy' (default: 0.1)
%                       If empty or with option 'joint', use the dispersion
%                       matrices in the structure
%   'SigmaR',S          Std of noise for rotations with 'Noisy' (default: 0.1)
%                       If empty or with option 'joint', use the dispersion
%                       matrices in the structure
%
%   'MethodAbsolutePoses', method
%                       How to interpret ground truth poses. It has effect
%                       only with the 'Essential' method 
%       'Pose'
%       'Reference'

%%AUTORIGHTS%%

% TODO: add options to add noise indipendently to rotation, translation and
% scales like in testNetworkInitializeStates 

function t_node=testNetworkAddMeasurements(t_node,varargin)
methodAbsolutePoses='reference';
method='truth';
N=length(t_node);
X=[];
flagGenerateImages=false;   %force the generation of images 
flagNormalize=true;         %normalize the measured translation
flagJoint=false;            %when using dispersion matrices, generate rotation and translation noises jointly
givenMeasurements=[];       %measurements passed with method 'Given'
outliersList=[];            %list of node pairs to change to outliers with method 'Outliers'

sigmaNoiseRelR=0.1;
sigmaNoiseRelT=0.1;

%optional parameters
ivarargin=1;
while(ivarargin<=length(varargin))
    switch(lower(varargin{ivarargin}))
        case 'method'
            ivarargin=ivarargin+1;
            method=varargin{ivarargin};
            switch lower(method)
                case 'given'
                    ivarargin=ivarargin+1;
                    givenMeasurements=varargin{ivarargin};
                case 'givenrotations'
                    ivarargin=ivarargin+1;
                    givenRotations=varargin{ivarargin};
                case {'outliers','outliertranslations'}
                    ivarargin=ivarargin+1;
                    outliersList=varargin{ivarargin};
                otherwise
                    %do nothing
            end
        case 'points'
            ivarargin=ivarargin+1;
            X=varargin{ivarargin};
            flagGenerateImages=true;
        case 'sigmar'
            ivarargin=ivarargin+1;
            sigmaNoiseRelR=varargin{ivarargin};
        case 'sigmat'
            ivarargin=ivarargin+1;
            sigmaNoiseRelT=varargin{ivarargin};
        case 'joint'
            flagJoint=true;
        case 'unnormalized'
            flagNormalize=false;
        case 'sigmanoise'
            ivarargin=ivarargin+1;
            sigmaNoise=varargin{ivarargin};
        case 'references'
            methodAbsolutePoses='reference';
        case 'poses'
            methodAbsolutePoses='pose';
        case 'methodabsoluteposes'
            ivarargin=ivarargin+1;
            methodAbsolutePoses=lower(varargin{ivarargin});
        otherwise
                error(['Argument ' varargin{ivarargin} ' not valid!'])
    end
    ivarargin=ivarargin+1;
end

structType=testNetworkDetectStructType(t_node);

%get network edges and set default normalize relative translation function
switch structType
    case 'single'
        E=t_node.E;
        edgeFunNormalize=@edgeFunNormalizeSingle;
        edgeFunEssential=@edgeFunEssentialSingle;
    case 'array'
        A=cat(1,t_node.aij);
        [E1,E2]=find(A~=0);
        E=[E1 E2];
        edgeFunNormalize=@edgeFunNormalizeArray;
        edgeFunEssential=@edgeFunEssentialArray;
end


%add measured relative changes of reference
if ~isfield(t_node,'gij')
    [t_node.gij]=deal(repmat(eye(4),[1,1,N]));
end
switch lower(method)
    case 'truth'
        [t_node.gij]=deal(t_node.gijtruth);
        if flagNormalize
            t_node=testNetworkExecFunOnEdges(t_node,edgeFunNormalize,E);
        end
        
    case 'truthrotationsonly'
        switch structType
            case 'single'
                t_node.gij(1:3,1:3,:)=t_node.gijtruth(1:3,1:3,:);
            case 'array'
                for iNode=1:N
                    t_node(iNode).gij(1:3,1:3,:)=t_node(iNode).gijtruth(1:3,1:3,:);
                end
        end
        
    case 'noisy'
        if ~flagJoint
            sR=sigmaNoiseRelR;
            sT=sigmaNoiseRelT;
            switch structType
                case 'single'
                    if isempty(sR)
                        sR=t_node.dispersionMatR;
                    end
                    if isempty(sT)
                        sT=t_node.dispersionMatT;
                    end
                    t_node.gij=noiserigid(t_node.gijtruth,sR,sT);
                case 'array'
                    for iNode=1:N
                        if isempty(sR)
                            sR=t_node(iNode).dispersionMatR;
                        end
                        if isempty(sT)
                            sT=t_node(iNode).dispersionMatT;
                        end
                        t_node(iNode).gij=noiserigid(t_node(iNode).gijtruth,sR,sT);
                    end
            end
        else
            switch structType
                case 'single'
                    s=t_node.dispersionMat;
                    t_node.gij=noiserigid(t_node.gijtruth,s);
                case 'array'
                    for iNode=1:N
                        s=t_node(iNode).dispersionMat;
                        t_node(iNode).gij=noiserigid(t_node(iNode).gijtruth,s);
                    end
            end
        end
        if flagNormalize
            t_node=testNetworkExecFunOnEdges(t_node,edgeFunNormalize,E);
        end
      
    case 'essential'
        if ~isfield(t_node,'ximage') || flagGenerateImages
            %generate images if not already done
            if isempty(X)
                error('You need to add the option ''Points'' or first call testNetworkProjectImages')
            end
            t_node=testNetworkProjectImages(t_node,X,'MethodAbsolutePoses',methodAbsolutePoses);
        end
        t_node=testNetworkExecFunOnEdges(t_node, edgeFunEssential,E);

    case 'given'
        switch structType
            case 'single'
                t_node.gij=givenMeasurements;
            case 'array'
                t_node=testNetworkExecFunOnEdges(t_node,...
                    @(t_node,iNode,jNode) edgeFunCopyMeasurement(t_node,iNode,jNode,givenMeasurements));
        end
        
    case 'givenrotations'
        switch structType
            case 'single'
                t_node.gij(1:3,1:3,:)=givenRotations;
            case 'array'
                t_node=testNetworkExecFunOnEdges(t_node,...
                    @(t_node,iNode,jNode) edgeFunCopyRotations(t_node,iNode,jNode,givenMeasurements));
        end                
        
    case 'outliers'
        for iEdgeOutl=1:size(outliersList,1)
            gOut=[rot_randn(eye(3)) cnormalize(randn(3,1)); zeros(1,3) 1];
            switch structType
                case 'single'
                    t_node.gij(iEdgeOutl)=gOut;
                    idxRev=t_node.idxRevE(iEdge);
                    if idxRev>0
                        t_node.gij(idxRev)=invg(gOut);
                    end
                case 'array'
                    iNode=outliersList(iEdgeOutl,1);
                    jNode=outliersList(iEdgeOutl,2);
                    t_node(iNode).gij(1:3,1:4,jNode)=gOut;
                    t_node(jNode).gij(1:3,1:4,iNode)=invg(gOut);
            end
        end

    case 'outliertranslations'
        for iEdgeOutl=1:size(outliersList,1)
            iNode=outliersList(iEdgeOutl,1);
            gOut=[t_node(iNode).gij(1:3,1:3,iEdgeOutl) cnormalize(randn(3,1))];
            switch structType
                case 'single'
                    t_node.gij(iEdgeOutl)=gOut;
                    idxRev=t_node.idxRevE(iEdge);
                    if idxRev>0
                        t_node.gij(idxRev)=invg(gOut);
                    end
                case 'array'
                    jNode=outliersList(iEdgeOutl,2);
                    t_node(iNode).gij(1:3,1:4,jNode)=gOut;
                    t_node(jNode).gij(1:3,1:4,iNode)=invg(gOut);
            end
        end
        
    otherwise
        error('MATLAB:ArgumentInvalid','Method %s not recognized',method)
end

% Various functions executed on edges
function t_node=edgeFunNormalizeSingle(t_node,iEdge)
t_node.gij(1:3,4,iEdge)=cnormalize(t_node.gij(1:3,4,iEdge));

function t_node=edgeFunNormalizeArray(t_node,iNode,jNode)
t_node(iNode).gij(1:3,4,jNode)=cnormalize(t_node(iNode).gij(1:3,4,jNode));

function t_node=edgeFunEssentialSingle(t_node,iEdge)
iNode=t_node.E(iEdge,1);
jNode=t_node.E(iEdge,2);

x1=t_node.ximage{iNode};
x2=t_node.ximage{jNode};
E=epipolarEstimateE8pt(x1,x2);
[R,p] = epipolarEToRT(E,x1,x2);
t_node.gij(:,:,iEdge)=[R p; zeros(1,3) 1];

function t_node=edgeFunEssentialArray(t_node,iNode,jNode)
x1=t_node(iNode).ximage;
x2=t_node(jNode).ximage;
[R,p] = discrete_motion(x1,x2);
t_node(iNode).gij(:,:,jNode)=[R p; zeros(1,3) 1];

function t_node=edgeFunCopyMeasurement(t_node,iNode,jNode,pairPoses)
t_node(iNode).gij(:,:,jNode)=pairPoses{iNode,jNode};

function t_node=edgeFunCopyRotations(t_node,iNode,jNode,pairRotations)
t_node(iNode).gij(1:3,1:3,jNode)=pairRotations{iNode,jNode};
