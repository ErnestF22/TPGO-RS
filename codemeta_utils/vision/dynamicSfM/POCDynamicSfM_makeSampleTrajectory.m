function POCDynamicSfM_makeSampleTrajectory(flagConsistencyChecks)
g=-[0;0;9.8];

if ~exist('flagConsistencyChecks','var')
    flagConsistencyChecks=true;
end

fileNameLoad='../../control/rigid/quadrotor_controlPDRT_test_movingReference_data.mat';
fprintf('Loading data from %s\n',fileNameLoad);

s=load(fileNameLoad);
%Extrinsic calibration matrix from the camera to the body in the simulation.
%It will affect all the quantities related to rotations: R, w and Gamma.
%In practice, the "body coordinates" will in fact be "camera coordinates".
Rbc=blkdiag(1,[0 -1;1 0]);
eThrust=Rbc'*[0;0;1];

%Where to translate origin
XOrigin=[0;-5;0];

%Time instants at which the state is available
t=s.t;

disp(' - State')
x=s.x;
disp(' - Derivative of the state as generated by the model')
dx=s.closedLoop(t,x);
disp(' - Inputs generated by the control law')
[Gamma,Theta]=quadrotor_inputUnpack(s.control(t,x));
Gammab=Rbc'*Gamma;

disp(' - Model parameters')
J=Rbc'*s.J*Rbc;
m=s.m;

disp(' - Camear pose, velocities and acceleration')
[R,w,Tsb,dTsb]=rigidDyn_stateUnpackRT(x);
%Translate trajectory to put the origin at XOrigin
Tsb=Tsb-XOrigin*ones(1,size(Tsb,2));

Rsb=multiprod(R,Rbc);
wb=Rbc'*w;
[~,ddTsb]=realDyn_stateUnpack(dx);
Rbs=invR(Rsb);
dRbs=-multiprod(hat3(wb),Rbs);
if flagConsistencyChecks
    disp(' -- Check consistency')
    funCheckDerInterpInterp(t,Tsb,dTsb)
    funCheckDerInterpInterp(t,dTsb,ddTsb)
    funCheckDerInterpInterp(t,Rbs,dRbs)
end

hwb=hat3(wb);

disp(' - Position, velocity and acceleration rotated in the body frame')
taub=multiprodMatVec(Rbs,Tsb);
nub=multiprodMatVec(Rbs,dTsb);
alphab=multiprodMatVec(Rbs,ddTsb);
if flagConsistencyChecks
    disp(' -- Check consistency with inputs')
    disp(norm(vec(alphab-eThrust*Theta/m-multiprodMatVec(Rbs,g)),'inf'))
end
disp(' - Their derivatives')
dtaub=-multiprodMatVec(hwb,taub)+nub;
dnub=-multiprodMatVec(hwb,nub)+alphab;
dwb=J\(Gammab-rotDyn_gyroscopicTerm(wb,'inertiaMatrix',J));
if flagConsistencyChecks
    disp(' -- Check consistency')
    funCheckDerInterpInterp(t,taub,dtaub)
    funCheckDerInterpInterp(t,nub,dnub)
    funCheckDerInterpInterp(t,wb,dwb)
end

disp(' - IMU measurements')
alphaIMU=multiprodMatVec(Rbs,ddTsb+repmat(g,1,size(ddTsb,2)));
wIMU=wb;

fileNameSave='sampleTrajectory';
save(fileNameSave)
fprintf('Processed data saved to %s\n',fileNameSave);

