function [ m, flagFeasible ] = TR3xR3_LMIopt2( e_A, e_B, kv, kd, kp, beta )
% Use the LMI as the objective and constraint. NOTE this method has not
% been shown to have max and min contraction eigenvalues at the max and min
% eigenvalues of the Hessisan.
% Bound method: Do not split matric but bound 1-norm by sqrt(3)*2-norm
% INPUT:
%   e_A := eigenvalue range for the A matrix corresponding to rho(x,xd)
%      [min;max]
%   e_B := eigenvalue range for the B matrix correspondding to rho(xd,0)
%       [min;max]
%   kd,kv,kp := positive scalar position/velocity/ref. position gain
%   beta := positive scalar for min convergence rate
% OUTPUT:
%   m := [m1 m2 m6;m2 m3 m5;m6 m5 m4] values
%   flagFeasible := boolean where true means the system is feasible

%% Default Parameters
flagFeasible = false; %set to false by default
%% Optimize using LMI as constraints
cvx_begin sdp quiet
    variable m(3,3) semidefinite
    % Re-assign vars
    m1 = m(1,1); m2 = m(1,2); m3 = m(2,2); m4 = m(3,3); m5 = m(2,3); m6 = m(1,3);
    % Define the discs of A
    DA_1 = @(e_A,e_B) -2*m2*kd*e_A + m1*beta ...
        + sqrt(3)*abs(-m3*kd*e_A + m1-m2*kv + beta*m2)...
        + sqrt(3)*abs((m2-m5)*kd*e_A + beta*m6)...
        + sqrt(3)*abs(-m6*kp*e_B);
    DA_2 = @(e_A,e_B) 2*(m2-m3*kv) + m3*beta ...
        + sqrt(3)*abs(-m3*kd*e_A + m1-m2*kv + beta*m2)...
        + sqrt(3)*abs(m3*kd*e_A + m6-m5*kv + beta*m5)...
        + abs(-m5*kp*e_B);
    DA_3 = @(e_A,e_B) sqrt(3)*abs(2*m5*kd*e_A + m4*beta) - 2*m4*kp*e_B...
        + sqrt(3)*abs((m2-m5)*kd*e_A + beta*m6)...
        + sqrt(3)*abs(-m6*kp*e_B)...
        + sqrt(3)*abs(m3*kd*e_A + m6-m5*kv + beta*m5)...
        + abs(-m5*kp*e_B);
    % Define the set we need max of
    set_A = [DA_1(e_A(1),e_B(1));...
        DA_1(e_A(1),e_B(2));...
        DA_1(e_A(2),e_B(1));...
        DA_1(e_A(2),e_B(2));...
        DA_2(e_A(1),e_B(1));...
        DA_2(e_A(1),e_B(2));...
        DA_2(e_A(2),e_B(1));...
        DA_2(e_A(2),e_B(2));...
        DA_3(e_A(1),e_B(1));...
        DA_3(e_A(1),e_B(2));...
        DA_3(e_A(2),e_B(1));...
        DA_3(e_A(2),e_B(2))];
        
    % Setup feasibility SDP (no objective)
    m4 == 1 % fix one entry of metric tensor for scale
    max(set_A) <= 0
    
    m >= 1e-4*eye(3) % make sure metric is positive definte up to some tolerance
cvx_end

if  strcmp(lower(cvx_status),'solved')
    eM = eig(m);
    if (all(eM > 0) && max(set_A) <= 0)
        flagFeasible = true;
    end
end

end

