function [M] = rotRef_contractionMat(U, lambda, kd, kv, m_nonnatural, varargin)
% Computes the matrix form of the M matrix (on TSO(3)xSO(3)) such that 
% [nu zeta eta]*M*[nu;zeta;eta] == g(\nabla_{Vx}X + lambda*Vx,Vx)_m, where
% zeta and eta are the R^3 representation of the horizontal and vertical
% tangent vectors of Vx on TSO(3) and nu is the R^3 vector on SO(3)
% ASSUMES: Vx = [RRef*hat3(nu);R*hat3(zeta);R*hat3(eta)];
% ASSUMES: X = [log(RRef,eye(3));U;kd*rot_log(R,RRef)-kv*U];
% NOTE: Terms are given by the nonnatural expression of the metric
% INPUTS:
%   U(R) := the tangent vector at R which creates the curve on TSO(n) in
%       the form of [R; U]
%   lambda := scalar for the exponential convergence rate
%   kd := scalar positive position gain
%   kv := scalar positive velocity gain
%   m_nonnatural := nonnatural metric gain matrix on TSO(3)xSO(3) in the form of [m4 m5 m6; m5 m1 m2;m6 m2 m3]
% OUTPUTS:
%   M(R,RRef) := M matrix such that 
%       [nu zeta eta]'*M*[nu;zeta;eta] == g(\nabla_{Vx}X + lambda*Vx,Vx)_m

flagOutputSymmetric = false;

%optional parameters
ivarargin=1;
while ivarargin<=length(varargin)
    switch lower(varargin{ivarargin})
        case 'sym'
            flagOutputSymmetric = true;
        otherwise
            error(['Argument ' varargin{ivarargin} ' not valid!'])
    end
    ivarargin=ivarargin+1;
end

%% Standard Variables
% Define gains for metric on TSO(3)xSO3
% Transform the metric from the "nonnatural" coordinates into the "natural"
% coordinates so we can compute the contraction matrix using the natural
% covar on TSO3xSO3 using Schur's complement
[J,m_natural] = rotRef_SchurComplement(m_nonnatural);
m1 = m_nonnatural(2,2); m2 = m_nonnatural(2,3); m3 = m_nonnatural(3,3);
m4 = m_nonnatural(1,1); m5 = m_nonnatural(1,2); m6 = m_nonnatural(1,3);
alpha = J(2,1); beta = J(3,1);
%% Compute the components of the M matrix on TSO(3)
% Extract the system velocity
w = rot_vee(eye(3), U(eye(3)));
detM_TSO3 = m1*m3-m2^2;
if flagOutputSymmetric
    M11 = @(R,RRef) zeros(3); % TODO
else
    M11 = @(R,RRef) -m4*rot3_logDiffMat(eye(3),RRef) + m5*beta*eye(3)...
        +m6*kd*rot3_logDiffMat(R,RRef) - m6*kd*alpha*rot3_logDiffMat(RRef,R)...
        -m6*kv*beta*eye(3) + m2*alpha^2/4*hat3(w)*hat3(w)...
        -m2*alpha^3/4*hat3(w)*rot_log(eye(3),RRef)...
        +(m1*m3*m6-m2*m3*m5)/(8*detM_TSO3)*alpha*hat3(w)*hat3(w)...
        -(m1*m3*m6-m2*m3*m5)/(8*detM_TSO3)*alpha^2*rot_log(eye(3),RRef)*hat3(w)...
        +m3*alpha/8*beta*hat3(w)*hat3(w)...
        -m3*alpha^2*beta/8*hat3(w)*rot_log(eye(3),RRef);
end

M12 = @(R,RRef) m5*alpha/2*rot_log(eye(3),RRef)-m5/2*hat3(w)+m6/2*kv*hat3(w)...
    +m6/2*beta*rot_log(eye(3),RRef) - m6/2*kd*rot_log(eye(3),R'*RRef)...
    -m6*kd*rot3_logDiffMat(RRef,R) + m2/4*alpha*hat3(w)*hat3(w)...
    -m2/4*alpha^2*hat3(w)*rot_log(eye(3),RRef) + m3/8*beta*hat3(w)*hat3(w)...
    -m3/8*beta*alpha*hat3(w)*rot_log(eye(3),RRef);

M13 = @(R,RRef) m5*eye(3) - m6*kv*eye(3) + m3/8*alpha*hat3(w)*hat3(w)...
    -m3/8*alpha^2*rot_log(eye(3),RRef)*hat3(w);

M21 = @(R,RRef) -m5*rot3_logDiffMat(eye(3),RRef) + m5/2*rot_log(eye(3),RRef)...
    +m1/2*alpha^2*rot_log(eye(3),RRef) -m1/2*alpha*hat3(w) +m1*beta*eye(3)...
    -m1/2*alpha*rot_log(eye(3),RRef) +m2/2*alpha*kv*hat3(w)...
    +m2/2*alpha*beta*rot_log(eye(3),RRef) - m2/2*alpha*kd*rot_log(eye(3),R'*RRef)...
    -m2/2*beta*rot_log(eye(3),RRef) - m2*kd*alpha*rot3_logDiffMat(RRef,R)...
    +m2*kd*rot3_logDiffMat(R,RRef) -m2*kv*beta*eye(3) + m2/4*alpha*hat3(w)*hat3(w)...
    -m2/4*alpha^2*hat3(w)*rot_log(eye(3),RRef)...
    +(m1*m3*m6-m2*m3*m5)/(8*detM_TSO3)*hat3(w)*hat3(w)...
    -(m1*m3*m6-m2*m3*m5)/(8*detM_TSO3)*alpha*rot_log(eye(3),RRef)*hat3(w);

M22 = @(R,RRef) -m2*kd*rot3_logDiffMat(RRef,R) + m2/4*hat3(w)*hat3(w)...
    -m2/4*alpha*hat3(w)*rot_log(eye(3),RRef);

M23 = @(R,RRef) m1*eye(3) - m2*kv*eye(3) + m3/8*hat3(w)*hat3(w)...
    -m3/8*alpha*rot_log(eye(3),RRef)*hat3(w);

M31 = @(R,RRef) -m6*rot3_logDiffMat(eye(3),RRef) + m6/2*rot_log(eye(3),RRef)...
    +m2/2*alpha^2*rot_log(eye(3),RRef) - m2/2*alpha*hat3(w)...
    -m2/2*alpha*rot_log(eye(3),RRef) + m2*beta*eye(3) + m3/2*alpha*kv*hat3(w)...
    +m3/2*alpha*beta*rot_log(eye(3),RRef) - m3/2*alpha*kd*rot_log(eye(3),R'*RRef)...
    -m3/2*beta*rot_log(eye(3),RRef) - m3*kd*alpha*rot3_logDiffMat(RRef,R)...
    +m3*kd*rot3_logDiffMat(R,RRef) - m3*kv*beta*eye(3)...
    +m3/8*alpha*hat3(w)*hat3(w) - m3*alpha^2/8*hat3(w)*rot_log(eye(3),RRef);

M32 = @(R,RRef) m2/2*alpha*rot_log(eye(3),RRef) - m2/2*hat3(w)...
    +m3/2*kv*hat3(w) + m3/2*beta*rot_log(eye(3),RRef) -m3/2*kd*rot_log(eye(3),R'*RRef)...
    -m3*kd*rot3_logDiffMat(RRef,R) + m3/8*hat3(w)*hat3(w) - m3*alpha/8*hat3(w)*rot_log(eye(3),RRef);

M33 = @(R,RRef) m2*eye(3) - m3*kv*eye(3);

%% Defined by copying from POC_rotRef_testContractionMetric
% % (nu',nu)
% M11 = @(R,RRef) -m4*rot3_logDiffMat(eye(3),RRef) +m5*beta*eye(3)...
%     +m6*kd*rot3_logDiffMat(R,RRef)...
%     - m6*kd*alpha*rot3_logDiffMat(RRef,R)...
%     - m6*kv*beta*eye(3)...
%     +m2*alpha/4*alpha*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef))...
%     +(m1*m3*m6-m2*m3*m5)/(8*(m1*m3-m2^2))*alpha*(hat3(w)-alpha*rot_log(eye(3),RRef))*hat3(w)...
%     +m3*alpha/8*beta*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef));
% % (nu',zeta)
% M12 = @(R,RRef) m5/2*(alpha*rot_log(eye(3),RRef)-hat3(w))...
%     +m6/2*(kv*hat3(w)+beta*rot_log(eye(3),RRef)-kd*rot_log(eye(3),R'*RRef))...
%     - m6*kd*rot3_logDiffMat(RRef,R)...
%     +m2/4*alpha*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef))...
%     +m3/8*beta*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef));
% % (nu', eta) 
% M13 = @(R,RRef) m5*eye(3) -m6*kv*eye(3) ...
%     +m3/8*alpha*(hat3(w)-alpha*rot_log(eye(3),RRef))*hat3(w);
%     
% % (zeta', nu)0
% M21 = @(R,RRef) -m5*rot3_logDiffMat(eye(3),RRef) + m5/2*rot_log(eye(3),RRef)...
%     +m1/2*(alpha^2*rot_log(eye(3),RRef)-alpha*hat3(w)-alpha*rot_log(eye(3),RRef))...
%     +m1*beta*eye(3) ...
%     +m2/2*(alpha*kv*hat3(w) + alpha*beta*rot_log(eye(3),RRef) - alpha*kd*rot_log(eye(3),R'*RRef))...
%     - m2*kd*alpha*rot3_logDiffMat(RRef,R)...
%     + m2*kd*rot3_logDiffMat(R,RRef)...
%     -m2/2*beta*rot_log(eye(3),RRef)...
%     -m2*kv*beta*eye(3)...
%     +m2*alpha/4*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef))...
%     +(m1*m3*m6-m2*m3*m5)/(8*(m1*m3-m2^2))*(hat3(w)-alpha*rot_log(eye(3),RRef))*hat3(w);
% % (zeta', zeta)
% M22 = @(R,RRef) -m2*kd*rot3_logDiffMat(RRef,R)...
%     +m2/4*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef));
% % (zeta', eta)
% M23 = @(R,RRef)  m1*eye(3)-m2*kv*eye(3) +m3/8*(hat3(w)-alpha*rot_log(eye(3),RRef))*hat3(w);
%     
% % (eta', nu)
% M31 = @(R,RRef) -m6*rot3_logDiffMat(eye(3),RRef) + m6/2*rot_log(eye(3),RRef)...
%     +m2/2*(alpha^2*rot_log(eye(3),RRef) - alpha*hat3(w) - alpha*rot_log(eye(3),RRef))...
%     +m2*beta*eye(3)...
%     +m3/2*(alpha*kv*hat3(w)+alpha*beta*rot_log(eye(3),RRef)-alpha*kd*rot_log(eye(3),R'*RRef))...
%     -m3*kd*alpha*rot3_logDiffMat(RRef,R)...
%     +m3*kd*rot3_logDiffMat(R,RRef)...
%     -m3/2*beta*rot_log(eye(3),RRef)...
%     -m3*kv*beta*eye(3)...
%     +m3*alpha/8*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef));
% % (eta', zeta)
% M32 = @(R,RRef) +m2/2*(alpha*rot_log(eye(3),RRef)-hat3(w))...
%     +m3/2*(kv*hat3(w)+beta*rot_log(eye(3),RRef)-kd*rot_log(eye(3),R'*RRef))...
%     -m3*kd*rot3_logDiffMat(RRef,R)...
%     +m3/8*hat3(w)*(hat3(w)-alpha*rot_log(eye(3),RRef));
% % (eta', eta)
% M33 = @(R,RRef)  m2*eye(3) -m3*kv*eye(3);
%% 
% Return the resulting contraction matrix
M = @(R,RRef) [M11(R,RRef) M12(R,RRef) M13(R,RRef);...
    M21(R,RRef) M22(R,RRef) M23(R,RRef);...
    M31(R,RRef) M32(R,RRef) M33(R,RRef)];
    
    
end

